basic syntax
use HCL - HashiCorp configuration Language 


block parameter {

      arguments
}

in block  :  if  you want to create infra like vm, docker contaner etc add "resource" block , 
             if you want to show some output through terraform then add "output" block, 
             if you want to store some variable then add "variable" block, 

in Parameter :  you have to add what type of resource and resource name , output and var you have to add
              so resource name tht you are adding that is jst the resource name of the terraform parameter not the actual infra name ,
              the infra name that you will create will be under arguments 

like resource        aws_instance              my_new_vm     {  #here in aws_instance the aws is the provider which you can fnd in .terraform folder
    ---------       ---------               -------------
    block        parameter-resourcetype       resource name                                 arguments like name size 
     
}


first do terraform init -- to initialize terraform in the folder 
terraform validate --  to validate the .tf file that is correct or not 
terraform plan -- to check the output / like what you will get after executing the tf file /like a dry run 
terraform apply -- to get the final run output 
terraform destroy -- to destroy the infra that you created
terraform apply -auto-approve  --  auto-approve  while applying 

example : 
terraform plan

  # local_file.my_file will be created
  + resource "local_file" "my_file" {
      + content              = "this is a new file created by me"
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "my_file.txt"
      + id                   = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

here you can see some are showing (known after apply)  so these are "attributes" which you will ge after the execution and the value like these  filename = "my_file.txt" 
that you added before the execution are "arguments".

so here local_file in this local is the provider - if you check in terraform foler you will get .terraform >> provider >> registry.terraform.io >> hashicorp >> local 

so that last local is the provider , and when you use these resource type it and aply it will download and add the respective provider in this folder
the provider is like lets say you want to create a resource from aws so aws is the provider 

if i want to manually install a provider --- create a terraform.tf file 
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"           #  these are arguments
      version = "6.4.0"
    }
  }
}    like this To install this provider, copy and paste this code into your Terraform configuration. Then, run terraform init.
here terraform is the name of the block 

## to connect to a cloud account you need to install cli like aws or azure cli  and login to your account
follow the steps of the login according to the cloud , and you have to craete a user in IAM and give the user access to create the resources in the preffered cloud
the user should be created t=in the cloud portal

Absolutely ‚Äî here‚Äôs a concrete example project structure showing how and why splitting .tf files makes things cleaner and more scalable.

üóÇÔ∏è Example Project Structure

my-terraform-project/
‚îú‚îÄ‚îÄ terraform.tf       ‚Üê Required providers
‚îú‚îÄ‚îÄ provider.tf        ‚Üê Provider setup / credentials
‚îú‚îÄ‚îÄ resource-group.tf  ‚Üê Resource group definition
‚îú‚îÄ‚îÄ network.tf         ‚Üê Virtual network and subnet
‚îú‚îÄ‚îÄ vm.tf              ‚Üê Virtual machine definition
‚îî‚îÄ‚îÄ variables.tf       ‚Üê Input variables

------
use reference of a resource in another resource block 

lets say you created a VPC for aws ec2 instance like this 

resource "aws_default_vpc" "my_vpc" {
       tags = {
         Name = "my_macvpc" 
       }
}

you then create a security group in which tyou need to specify the vpc id ,
  you can refer like this , ##  here you take the parameter_resource_type from the vpc resource and added the ame my_vpc that you assigned to the vpc resource and then .id or name that you want to add  like this :  vpc_id      = aws_default_vpc.my_vpc.id
THIS IS CALLED "INTERPOLATION" : it is a way in which you can inherit/extract the values from a terraform block 

  resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_default_vpc.my_vpc.id

}

so basically      """   parameter_resource_type.resourcename.thething_you_want  """

--------------
Variable In Terraform

TO REFERENCE variable in a resource block create a variable block and add var.var_name
variable "bucket_name" {
  description = "Name of the S3 bucket"
  type        = string
  default     = "my-unique-terraform-bucket-123"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = var.bucket_name
  acl    = "private"
}

this is a reference of output block
output "bucket_name" {
  description = "The name of the created S3 bucket"
  value       = aws_s3_bucket.my_bucket.bucket
}

---------------------
if you want to install anything in the instances /vm servers then you can add
""" user_data = file(install.sh) """

install.sh is the file where your bash installation script is there and 
"" remember it will only execute while creating the server fir the first time only ""

so user_data is the arguments who lets you run shell scripts or some shell command at the startup 

###terraform-variables
-------------------------------------------------

create a file for variables 

variables.tf

variable "filename" {
   default = "C:\\Users\\Debasish\\Desktop\\test_file\\dummy.txt"

}
and in main.tf 
resource "local_file" "dev-var" {
   filename = var.filename
   content = var.content
  
}
#another way to pass variable 
variable "region" {
  description = "AWS region"
  type        = string
}
export TF_VAR_region="us-east-1"  ## this you can pass in command line ,so you can see in the var section gthere is no default value so byt this yon can pass the default value 


variableble types:

In terraform every resource , variable and output blocks should have unique names , no repeation in values and all

the variable file should be in the same folder as terraform.th]fstate 
you can access 
Types:

| Type   | Description                     | Example                     |
| ------ | ------------------------------- | --------------------------- |
| string | Text value                      | `"us-east-1"`               |
| number | Numeric value                   | `3`                         |
| bool   | True or false                   | `true`                      |
| list   | Ordered collection              | `["a","b","c"]`             |
| map    | Key-value pairs                 | `{"key1":"value1"}`         |
| set    | Unique unordered elements       | `[1,2,3]`                   |
| object | Structured data with attributes | `{"cpu":4,"memory":"16GB"}` |
| tuple  | Ordered heterogeneous elements  | `[1,"abc"]`                 |


1. Map:  

Definition: Key-value pairs (like a dictionary in Python, or object in JSON).
When to use:
You need to look up values by key.
You want to group related simple values.

resource "local_file" "dummy_file" {
    filename = "C:\\Users\\Debasish.Panda\\Desktop\\test\\dummy.txt"
    content = var.content_map["content2"]
  
}

variable "content_map" {
    type = map
    default = {
        "content1" = "this is first value"
        "content2" = "this is second value"
        }
}

2. list: 

List

Definition: An ordered collection of values (duplicates allowed).
When to use:
You care about order (e.g., first, second, third).

You might reference elements by index (list[0])
in variable.tf: 


variable "filelist" {
    type = list
    default = ["C:\\Users\\Debasish.Panda\\Desktop\\test\\test23.txt","C:\\Users\\Debasish.Panda\\Desktop\\test\\test53.txt"]
	
}

in main.tf :
resource "local_file" "dummy_file" {
    filename = var.filelist[0]
    content = var.content_map["content1"]
  }
resource "local_file" "dummy1_file" {
    filename = var.filelist[1]
    content = var.content_map["content2"]
}

3. object: 
in here you will ad user defined data types like this 

Definition: A structured type with named attributes (like a record or schema).
When to use:
You want to enforce a schema with specific attribute names.
You‚Äôre modeling a complex resource configuration.

variable "aws_ec2_object" {

    type = object({
        name = string
        instances = number
        keys = list(string) 

    })
    default = {
       name = "my-app"
       instances = 2
       keys = ["gwydvywged536e24","sdbuwhbduhw24342"]
    }
}

in main.tf :
you can call the values like 

output "aws_ec21_info" {
 
     value = var.aws_ec2_object.name
}  

var.object_name.the_key_whichvalueyouwant


4 set :

Definition: An unordered collection of unique values.
When to use:
You don‚Äôt care about order.
You want to avoid duplicates automatically.

variable "allowed_ports" {
  type = set(number)
}

allowed_ports = [22, 80, 443, 443]  # Terraform will keep only 22, 80, 443







