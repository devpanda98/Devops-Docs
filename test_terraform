basic syntax
use HCL - HashiCorp configuration Language 


block parameter {

      arguments
}

in block  :  if  you want to create infra like vm, docker contaner etc add "resource" block , 
             if you want to show some output through terraform then add "output" block, 
             if you want to store some variable then add "variable" block, 

in Parameter :  you have to add what type of resource and resource name , output and var you have to add
              so resource name tht you are adding that is jst the resource name of the terraform parameter not the actual infra name ,
              the infra name that you will create will be under arguments 

like resource        aws_instance              my_new_vm     {  #here in aws_instance the aws is the provider which you can fnd in .terraform folder
    ---------       ---------               -------------
    block        parameter-resourcetype       resource name                                 arguments like name size 
     
}


first do terraform init -- to initialize terraform in the folder / it install the plugins that are there in the file
terraform validate --  to validate the .tf file that is correct or not 
terraform plan -- to check the output / like what you will get after executing the tf file /like a dry run /it creates a execution generated 
terraform apply -- to get the final run output / execution is done , creates a blueprint of that execution and state is maintained 
terraform destroy -- to destroy the infra that you created
terraform apply -auto-approve  --  auto-approve  while applying 

example : 
terraform plan

  # local_file.my_file will be created
  + resource "local_file" "my_file" {
      + content              = "this is a new file created by me"
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "my_file.txt"
      + id                   = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

here you can see some are showing (known after apply)  so these are "attributes" which you will ge after the execution and the value like these  filename = "my_file.txt" 
that you added before the execution are "arguments".

so here local_file in this local is the provider - if you check in terraform foler you will get .terraform >> provider >> registry.terraform.io >> hashicorp >> local 

so that last local is the provider , and when you use these resource type it and aply it will download and add the respective provider in this folder
the provider is like lets say you want to create a resource from aws so aws is the provider 

if i want to manually install a provider --- create a terraform.tf file 
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"           #  these are arguments
      version = "6.4.0"
    }
  }
}    like this To install this provider, copy and paste this code into your Terraform configuration. Then, run terraform init.
here terraform is the name of the block 

## to connect to a cloud account you need to install cli like aws or azure cli  and login to your account
follow the steps of the login according to the cloud , and you have to craete a user in IAM and give the user access to create the resources in the preffered cloud
the user should be created t=in the cloud portal

Absolutely ‚Äî here‚Äôs a concrete example project structure showing how and why splitting .tf files makes things cleaner and more scalable.

üóÇÔ∏è Example Project Structure

my-terraform-project/
‚îú‚îÄ‚îÄ terraform.tf       ‚Üê Required providers
‚îú‚îÄ‚îÄ provider.tf        ‚Üê Provider setup / credentials
‚îú‚îÄ‚îÄ resource-group.tf  ‚Üê Resource group definition
‚îú‚îÄ‚îÄ network.tf         ‚Üê Virtual network and subnet
‚îú‚îÄ‚îÄ vm.tf              ‚Üê Virtual machine definition
‚îî‚îÄ‚îÄ variables.tf       ‚Üê Input variables

------
use reference of a resource in another resource block 

lets say you created a VPC for aws ec2 instance like this 

resource "aws_default_vpc" "my_vpc" {
       tags = {
         Name = "my_macvpc" 
       }
}

you then create a security group in which tyou need to specify the vpc id ,
  you can refer like this , ##  here you take the parameter_resource_type from the vpc resource and added the ame my_vpc that you assigned to the vpc resource and then .id or name that you want to add  like this :  vpc_id      = aws_default_vpc.my_vpc.id
THIS IS CALLED "INTERPOLATION" : it is a way in which you can inherit/extract the values from a terraform block 

  resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_default_vpc.my_vpc.id

}

so basically      """   parameter_resource_type.resourcename.thething_you_want  """

--------------
Variable In Terraform

TO REFERENCE variable in a resource block create a variable block and add var.var_name
variable "bucket_name" {
  description = "Name of the S3 bucket"
  type        = string
  default     = "my-unique-terraform-bucket-123"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = var.bucket_name
  acl    = "private"
}

this is a reference of output block
output "bucket_name" {
  description = "The name of the created S3 bucket"
  value       = aws_s3_bucket.my_bucket.bucket
}

---------------------
if you want to install anything in the instances /vm servers then you can add
""" user_data = file(install.sh) """

install.sh is the file where your bash installation script is there and 
"" remember it will only execute while creating the server fir the first time only ""

so user_data is the arguments who lets you run shell scripts or some shell command at the startup 

###terraform-variables
-------------------------------------------------

create a file for variables 

variables.tf

variable "filename" {
   default = "C:\\Users\\Debasish\\Desktop\\test_file\\dummy.txt"

}
and in main.tf 
resource "local_file" "dev-var" {
   filename = var.filename
   content = var.content
  
}
#another way to pass variable 
variable "region" {
  description = "AWS region"
  type        = string
}
export TF_VAR_region="us-east-1"  ## this you can pass in command line ,so you can see in the var section gthere is no default value so byt this yon can pass the default value 


variableble types:

In terraform every resource , variable and output blocks should have unique names , no repeation in values and all

the variable file should be in the same folder as terraform.th]fstate 
you can access 
Types:

| Type   | Description                     | Example                     |
| ------ | ------------------------------- | --------------------------- |
| string | Text value                      | `"us-east-1"`               |
| number | Numeric value                   | `3`                         |
| bool   | True or false                   | `true`                      |
| list   | Ordered collection              | `["a","b","c"]`             |
| map    | Key-value pairs                 | `{"key1":"value1"}`         |
| set    | Unique unordered elements       | `[1,2,3]`                   |
| object | Structured data with attributes | `{"cpu":4,"memory":"16GB"}` |
| tuple  | Ordered heterogeneous elements  | `[1,"abc"]`                 |


1. Map:  

Definition: Key-value pairs (like a dictionary in Python, or object in JSON).
When to use:
You need to look up values by key.
You want to group related simple values.

resource "local_file" "dummy_file" {
    filename = "C:\\Users\\Debasish.Panda\\Desktop\\test\\dummy.txt"
    content = var.content_map["content2"]
  
}

variable "content_map" {
    type = map
    default = {
        "content1" = "this is first value"
        "content2" = "this is second value"
        }
}

2. list: 

List

Definition: An ordered collection of values (duplicates allowed).
When to use:
You care about order (e.g., first, second, third).

You might reference elements by index (list[0])
in variable.tf: 


variable "filelist" {
    type = list
    default = ["C:\\Users\\Debasish.Panda\\Desktop\\test\\test23.txt","C:\\Users\\Debasish.Panda\\Desktop\\test\\test53.txt"]
	
}

in main.tf :
resource "local_file" "dummy_file" {
    filename = var.filelist[0]
    content = var.content_map["content1"]
  }
resource "local_file" "dummy1_file" {
    filename = var.filelist[1]
    content = var.content_map["content2"]
}

3. object: 
in here you will ad user defined data types like this 

Definition: A structured type with named attributes (like a record or schema).
When to use:
You want to enforce a schema with specific attribute names.
You‚Äôre modeling a complex resource configuration.

variable "aws_ec2_object" {

    type = object({
        name = string
        instances = number
        keys = list(string) 

    })
    default = {
       name = "my-app"
       instances = 2
       keys = ["gwydvywged536e24","sdbuwhbduhw24342"]
    }
}

in main.tf :
you can call the values like 

output "aws_ec21_info" {
 
     value = var.aws_ec2_object.name
}  

var.object_name.the_key_whichvalueyouwant


4 set :

Definition: An unordered collection of unique values.
When to use:
You don‚Äôt care about order.
You want to avoid duplicates automatically.

variable "allowed_ports" {
  type = set(number)
}

allowed_ports = [22, 80, 443, 443]  # Terraform will keep only 22, 80, 443


##Terraform State::
-------------------------------------------------------------
commands: 
terraform state list ‚Üí list all resources in state.
terraform state show <resource> ‚Üí show details of one resource.
terraform state mv <from> <to> ‚Üí move resource within state (e.g., rename).
terraform state rm <resource> ‚Üí remove from state without destroying in cloud.

##Purpose: Stores Terraform‚Äôs view of the infrastructure (acts as source of truth).
Contents: JSON file with resource details (IDs, attributes, metadata).
Usage: Terraform compares .tf (desired) with .tfstate (current) to decide what to add/change/delete.
Key points:
Don‚Äôt edit manually.
If lost ‚Üí Terraform may recreate or orphan resources.
Keep it safe (use remote state for teams).

Terraform conditionals statements :
-----------------
Terraform doesn‚Äôt have traditional if { } else { } blocks.
Instead, it uses conditional expressions (also called ternary operators) in this form:

condition ? true_value : false_value

variable "env" {
  default = "dev"
}

resource "aws_instance" "example" {
  instance_type = var.env == "prod" ? "t3.large" : "t3.micro"
}


So Here if the var.env is prod (you will define with ==) the "? " here is kind of working as if statement , and before and after the "  : "

is working as the values. so here if the var.env is prod then in which ? is for if so if it is true means the value is prod then it will take the first value
before vaue and if not satisfies means var.env is not prod then it will take the after : value .


‚úÖ Example 2: Conditional count
resource "aws_instance" "example" {
  count = var.create_instance ? 1 : 0

  ami           = "ami-123456"
  instance_type = "t2.micro"
}


If var.create_instance is true, Terraform creates one instance.
If it‚Äôs false, it creates none.


üîπ Example 3: Nested conditions

You can nest conditionals too:

instance_type = var.env == "prod" ? "t3.large" : (
  var.env == "staging" ? "t3.medium" : "t3.micro"
)

Checks if the variable env equals "prod".
If ‚úÖ true ‚Üí result = "t3.large".
If ‚ùå false ‚Üí Terraform moves to what‚Äôs inside the parentheses ( ... ).

Next  one runs only if the first condition was false.

in Terraform, you don‚Äôt write if / elif / else directly like in Python ‚Äî
but you can simulate that same logic using either:

Nested conditionals (? :) ‚Äî like your example

A cleaner approach with lookup() or maps


üîπ Example 4: With locals
locals {
  bucket_name = var.is_prod ? "my-prod-bucket" : "my-dev-bucket"
}


Then use it:

resource "aws_s3_bucket" "example" {
  bucket = local.bucket_name
}



| Purpose                    | Example                                |
| -------------------------- | -------------------------------------- |
| General syntax             | `condition ? true_value : false_value` |
| Conditional resource count | `count = var.enabled ? 1 : 0`          |
| Nested condition           | `a ? b : (c ? d : e)`                  |



üöÄ  Terraform state management and Backends:
---------------
In Terraform, the TF state (short for Terraform state) is a file (terraform.tfstate file) that keeps track of the current state of your infrastructure as known to Terraform.

terraform refresh is a command that updates your Terraform state file (terraform.tfstate) with the real-world state of your infrastructure.

>>>>  terraform refresh

Terraform:
Reads the existing terraform.tfstate file.
Queries your providers (AWS, Azure, GCP, etc.) to get the current, real values of all resources.
Updates the local (or remote) state file to reflect those values.
It does not change your actual infrastructure ‚Äî it only updates the state.

‚öôÔ∏è Commands that interact with state

terraform show   ‚Äì view the current state.

terraform state list ‚Äì list all tracked resources.

terraform state show <resource> ‚Äì view details for a specific resource.

terraform state rm <resource> ‚Äì remove a resource from the state.  (it doesnt delete the actual resource it jst delete that resource part from tfstate file so you dont have to manage that resource through terraform )

terraform state mv ‚Äì move resources between states or rename them.

terraform import :

The terraform import command is used to bring an existing real-world resource (for example, an AWS EC2 instance or Azure storage account) into Terraform‚Äôs state ‚Äî so that Terraform can start managing it.

terraform import <resource_address> <real_resource_id>
ex:   terraform import aws_instance.myserver i-0a1b2c3d4e5f6g7h8











