âœ… Read command :
ex : 
echo "enter the name: "
read name
echo "name is $name"

## if you want to enter the input in same line (use p flag)
read -p 'username: ' user_var
echo "username : $user_var"
## if you dont want to show the input that the user is giving (use s flag)
read -sp 'username: ' user_var
echo ## add this line otherwise the input and the output will be in the same line, read -s, the input does not move to a new line after the user presses Enter.
                                Without this, your next output would appear on the same line as your prompt.
echo "username : $user_var"

## to print the inputs as an ARRAY:(user a flag)
echo "enter names"
read -a names
echo "Names : ${names[0]}, ${names[1]}"   (it will use indexing to print the values )

output : Names: ram, shyam

##  lets say u dint give any variable to read command , in that case you can use builtin variable $REPLY it will take the values

echo "enter the name: "
read 
echo "name is $REPLY"


âœ… Solution 1 â€” Parse Comma-Separated Input

We can read the whole line into one variable, then split it by commas using IFS (Internal Field Separator): (user -r flag to get raw inputs)

#!/bin/bash
read -p 'Enter three numbers (comma separated): ' input
# Split input by commas
IFS=',' read -r num1 num2 num3 <<< "$input"
sum=$((num1 + num2 + num3))
echo "Sum of the numbers is $sum"

## Use -t then add the time limit in sec, here

BASH FLAGS TO USE :
| Flag        | Description                                                                    | Example                                       | Notes                                                           |
| ----------- | ------------------------------------------------------------------------------ | --------------------------------------------- | --------------------------------------------------------------- |
| `-p`        | **Prompt** â€“ Display a message before waiting for input.                       | `read -p "Enter name: " name`                 | Most commonly used; shows inline prompt.                        |
| `-s`        | **Silent input** â€“ Donâ€™t echo what the user types.                             | `read -sp "Password: " pass`                  | Used for passwords; input is hidden.                            |
| `-t`        | **Timeout** â€“ Stop waiting after *N* seconds.                                  | `read -t 5 -p "Enter value: " var`            | If time expires, exit code is non-zero (`$? = 1`).              |
| `-n`        | **Character limit** â€“ Accept only *N* characters, then continue automatically. | `read -n 1 -p "Press any key: " key`          | Great for â€œpress any key to continueâ€ prompts.                  |
| `-r`        | **Raw mode** â€“ Donâ€™t interpret backslashes (`\`) as escape characters.         | `read -r line`                                | Always use this when reading arbitrary text (e.g., file paths). |
| `-a`        | **Array mode** â€“ Store input words into an array.                              | `read -a arr`                                 | Access values like `${arr[0]}`, `${arr[1]}` etc.                |
| `-d`        | **Delimiter** â€“ Stop reading when this character is found.                     | `read -d ';' input`                           | Default delimiter is newline (`\n`).                            |
| `-N`        | **Read exactly N characters** (waits until all N are entered).                 | `read -N 5 code`                              | Useful for fixed-length inputs like OTPs.                       |
| `-u`        | **Read from file descriptor N** instead of standard input.                     | `read -u 3 line`                              | Used for reading from open files or subshells.                  |
| `-e`        | **Enable readline editing** (arrow keys, history, etc.)                        | `read -e -p "Command: " cmd`                  | Only works in interactive shells; lets you use line editing.    |
| `-i`        | **Provide default text** (requires `-e`).                                      | `read -e -i "default" -p "Enter value: " var` | Lets user edit default input easily.                            |
| `-n` & `-s` | Combine to hide and limit input to N chars.                                    | `read -n 1 -s key`                            | Example: press any key silently.                                |



| Feature            | Description                                                | Example                                     |
| ------------------ | ---------------------------------------------------------- | ------------------------------------------- |
| `IFS`              | Change input field separator (default: space/tab/newline). | `IFS=',' read -r a b c <<< "1,2,3"`         |
| `<<<`              | â€œHere-stringâ€ â€“ Feed a variable as input to 
`read`.        | `read var <<< "$data"`                      |
| `-` after options  | Stops flag parsing (treat next args as data).              | `read -- -name` reads `-name` literally.    |
| `exit code` (`$?`) | `0` if input received, `1` if timeout (with `-t`).         | `if [ $? -ne 0 ]; then echo "Timeout!"; fi` |

ðŸ‘ Comparison Operators:
----------------------
ðŸ§© 1. Three Different Comparison Contexts in Bash

| Context     | Syntax                | Type of Comparison                                  | Example         |
| ----------- | --------------------- | --------------------------------------------------- | --------------- |
| `[ ... ]`   | Test command          | Strings / Files / Numbers (with `-eq`, `-lt`, etc.) | `[ $a -lt $b ]` |
| `[[ ... ]]` | Extended test         | Safer for strings, supports pattern matching        | `[[ $a < $b ]]` |
| `(( ... ))` | Arithmetic evaluation | **Pure integer math & comparison**                  | `(( a < b ))` âœ… |


Bash actually has two sets of comparison operators:
One set for numbers (arithmetic comparison)
Another set for strings (text comparison)

ðŸ§® 1. Numeric Comparison Operators
Used when comparing numbers (integers).

| Operator | Meaning                  | Example         | Result |
| -------- | ------------------------ | --------------- | ------ |
| `-eq`    | equal to                 | `[ 5 -eq 5 ]`   | true   |
| `-ne`    | not equal to             | `[ 5 -ne 8 ]`   | true   |
| `-lt`    | less than                | `[ 3 -lt 5 ]`   | true   |
| `-le`    | less than or equal to    | `[ 3 -le 3 ]`   | true   |
| `-gt`    | greater than             | `[ 10 -gt 5 ]`  | true   |
| `-ge`    | greater than or equal to | `[ 10 -ge 10 ]` | true   |


ðŸ”¢ 2. Using (( )) for Integer Comparison

Inside (( )), you donâ€™t use -lt, -gt, etc.
You can use normal arithmetic operators instead:

| Operator | Meaning                  |
| -------- | ------------------------ |
| `<`      | less than                |
| `<=`     | less than or equal to    |
| `>`      | greater than             |
| `>=`     | greater than or equal to |
| `==`     | equal to                 |
| `!=`     | not equal to             |


ðŸ§µ 3. String Comparison Operators
Used when comparing text (strings).

| Operator | Meaning                                    | Example                    | Result            |
| -------- | ------------------------------------------ | -------------------------- | ----------------- |
| `=`      | strings are equal                          | `[ "$a" = "$b" ]`          | true if same      |
| `==`     | strings are equal (also valid in `[[ ]]`)  | `[[ "$a" == "$b" ]]`       | true if same      |
| `!=`     | strings are not equal                      | `[ "$a" != "$b" ]`         | true if different |
| `<`      | string is less than (lexicographically)    | `[[ "apple" < "banana" ]]` | true              |
| `>`      | string is greater than (lexicographically) | `[[ "dog" > "cat" ]]`      | true              |
| `-z`     | string is empty                            | `[ -z "$str" ]`            | true if empty     |
| `-n`     | string is not empty                        | `[ -n "$str" ]`            | true if not empty |

ðŸ“‚ 3. File Test Operators

| Operator          | Test                  | True ifâ€¦                           |
| ----------------- | --------------------- | ---------------------------------- |
| `-e file`         | Exists                | File or directory exists           |
| `-f file`         | Regular file          | File exists and is not a directory |
| `-d file`         | Directory             | File is a directory                |
| `-r file`         | Readable              | File has read permission           |
| `-w file`         | Writable              | File has write permission          |
| `-x file`         | Executable            | File has execute permission        |
| `-s file`         | Non-empty             | File size > 0                      |
| `-L file`         | Symbolic link         | File is a symlink                  |
| `file1 -nt file2` | Newer than            | file1 is newer                     |
| `file1 -ot file2` | Older than            | file1 is older                     |
| `-O file`         | Owned by current user | true if owned                      |
| `-G file`         | Group ID matches      | true if group matches              |



ðŸ§  4. Combining Conditions

You can combine tests using:

-a â†’ AND
-o â†’ OR
! â†’ NOT


ðŸ§  Bash Operators Cheat Sheet
ðŸ”¹ 1. Arithmetic Operators (used inside (( ... )))
| Operator                     | Meaning             | Example            | Result              |
| ---------------------------- | ------------------- | ------------------ | ------------------- |
| `+`                          | Addition            | `(( a = b + c ))`  | Sum of b and c      |
| `-`                          | Subtraction         | `(( a = b - c ))`  | Difference          |
| `*`                          | Multiplication      | `(( a = b * c ))`  | Product             |
| `/`                          | Division            | `(( a = b / c ))`  | Quotient (integer)  |
| `%`                          | Modulus (remainder) | `(( a = b % c ))`  | Remainder           |
| `**`                         | Exponentiation      | `(( a = b ** 2 ))` | b squared           |
| `=`                          | Assignment          | `(( a = 5 ))`      | Assigns 5           |
| `+=`, `-=`, `*=`, `/=`, `%=` | Compound assignment | `(( a += 1 ))`     | Increment/decrement |
| `++`                         | Increment           | `(( a++ ))`        | Add 1               |
| `--`                         | Decrement           | `(( a-- ))`        | Subtract 1          |


ðŸ”¹ 2. Arithmetic Comparison Operators (inside (( ... )))

| Operator | Meaning          | Example        | True if...    |
| -------- | ---------------- | -------------- | ------------- |
| `==`     | Equal            | `(( a == b ))` | a equals b    |
| `!=`     | Not equal        | `(( a != b ))` | a not equal b |
| `<`      | Less than        | `(( a < b ))`  | a is less     |
| `<=`     | Less or equal    | `(( a <= b ))` | a â‰¤ b         |
| `>`      | Greater than     | `(( a > b ))`  | a > b         |
| `>=`     | Greater or equal | `(( a >= b ))` | a â‰¥ b         |

ðŸ”¹ 3. Logical Operators
Used to combine or control multiple commands or conditions.

| Operator | Meaning | Behavior                                             | Example                     |                                             |             |   |                |
| -------- | ------- | ---------------------------------------------------- | --------------------------- | ------------------------------------------- | ----------- | - | -------------- |
| `&&`     | AND     | Run next command **only if previous succeeds**       | `mkdir test && cd test`     |                                             |             |   |                |
| `        |         | `                                                    | OR                          | Run next command **only if previous fails** | `mkdir test |   | echo "Failed"` |
| `!`      | NOT     | Inverts the exit status (true â†’ false, false â†’ true) | `! false` (returns success) |                                             |             |   |                |


ðŸ”¹ 4. Redirection Operators

| Operator | Meaning                     | Example                  |
| -------- | --------------------------- | ------------------------ |
| `>`      | Redirect output (overwrite) | `echo "hi" > file.txt`   |
| `>>`     | Redirect output (append)    | `echo "hi" >> file.txt`  |
| `<`      | Redirect input              | `sort < file.txt`        |
| `2>`     | Redirect errors             | `ls /root 2> errors.log` |
| `&>`     | Redirect stdout + stderr    | `command &> output.log`  |


ðŸ”¹ 5. Miscellaneous Operators

| Operator | Meaning                       | Example                         |     |           |
| -------- | ----------------------------- | ------------------------------- | --- | --------- |
| `;`      | Command separator             | `cmd1; cmd2` (run sequentially) |     |           |
| `&`      | Run in background             | `longtask &`                    |     |           |
| `        | `                             | Pipe output to another command  | `ls | grep txt` |
| `()`     | Subshell (run in new shell)   | `(cd /tmp && ls)`               |     |           |
| `{}`     | Command grouping (same shell) | `{ echo A; echo B; }`           |     |           |


ðŸ§   Passing Arguments:
---------------------

ðŸ§® 2. How Bash Stores Arguments
Inside the script, Bash automatically assigns these to special variables:

| Variable | Meaning                          | Example                 |
| -------- | -------------------------------- | ----------------------- |
| `$0`     | The name of the script           | `./myscript.sh`         |
| `$1`     | First argument                   | `apple`                 |
| `$2`     | Second argument                  | `banana`                |
| `$3`     | Third argument                   | `cherry`                |
| `$@`     | All arguments as separate words  | `apple banana cherry`   |
| `$*`     | All arguments as a single string | `"apple banana cherry"` |
| `$#`     | Number of arguments passed       | `3`                     |


echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments: $@"
echo "Number of arguments: $#"

âœ… If Statement ( If then , If then else, If elif else):
--------------------------------------------

if [ condition ]; then
    # if condition is true
    commands
else
    # if condition is false
    other commands
fi




